#!/usr/bin/python2.7
# Authors:
#  Christian Heimes <cheimes@redhat.com>
#
# Copyright (C) 2015  Red Hat
# see file 'COPYING' for use and warranty information
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import logging
import os
import pwd
import subprocess

from ipalib import api
from ipalib import errors
from ipapython.dn import DN


logger = logging.getLogger('create-portal-user')

SELFSERVICE_GROUP = u'self-service'
SELFSERVICE_GROUP_DESCRIPTION = u"""Self-service users
Members of the group are able to use the self-service portal for some tasks,
e.g. request a password reset."""

SELFSERVICE_USER_PERMISSION = u'Self-Service Change User Password'
SELFSERVICE_STAGEUSER_PERMISSION = u'Self-Service Change Stage User Password'

SELFSERVICE_USERCLASS = u'self-service capable'
SELFSERVICE_AUTOMEMBER_DESCRIPTION = (
    u"Automember rule for self-service portals to add approved "
    u"self-registered users to self-service group."
)

PRIVILEGE = u'Self-Service Management Privilege'
PRIVILEGE_DESCRIPTION = u"Self-service portal privilege for e.g. password resets"
PRIVILEGE_PERMISSIONS = [
    SELFSERVICE_USER_PERMISSION,
    SELFSERVICE_STAGEUSER_PERMISSION,
    u'System: Add Stage User',
    u'System: Read Stage User',
    u'System: Read User Standard Attributes',
    u'System: Read User Addressbook Attributes',
]

ROLE = u'Self-Service Portal Management'
ROLE_DESCRIPTION = u'Self-service portals'

USER = u'self-service-portal'
USER_FIRST = u'Self-Service'
USER_LAST = u'Portal'

KEYTAB_OWNER = 'apache'
KEYTAB = '/etc/ipa/portal.keytab'


def tounicode(s):
    if s is None:
        return None
    return s.decode('utf-8')


parser = argparse.ArgumentParser(
    description='Create user for community portal'
)
parser.add_argument(
    '--selfservice-group',
    dest='selfservice_group',
    help="Group for self-service users (default: '%s')" % SELFSERVICE_GROUP,
    default=SELFSERVICE_GROUP,
    type=tounicode
)
parser.add_argument(
    '--userclass',
    dest='automember_userclass',
    help="User class value for automember rule (default: '%s')" % SELFSERVICE_USERCLASS,
    default=SELFSERVICE_USERCLASS,
    type=tounicode
)
parser.add_argument(
    '--privilege',
    dest='privilege',
    help="Privilege for portal management (default: '%s')" % PRIVILEGE,
    default=PRIVILEGE,
    type=tounicode
)
parser.add_argument(
    '--role',
    dest='role',
    help="Role name for portal management (default: '%s')" % ROLE,
    default=ROLE,
    type=tounicode
)
parser.add_argument(
    '--user',
    dest='username',
    help="Community portal user (default: '%s')" % USER,
    default=USER,
    type=tounicode
)
parser.add_argument(
    '--keytab-owner',
    dest='keytab_owner',
    help="Owner of the keytab file (default: '%s')" % KEYTAB_OWNER,
    default=KEYTAB_OWNER,
    type=pwd.getpwnam
)
parser.add_argument(
    '--keytab',
    dest='keytab',
    help="File name of Kerberos client keytab (default: '%s')" % KEYTAB,
    default=KEYTAB,
    type=str
)
parser.add_argument(
    '--no-keytab',
    dest='retrieve_keytab',
    help="Don't retrieve a client keytab (default: yes)",
    action='store_false'
)


def api_connect():
    """Initialize and connect to FreeIPA's RPC server.
    """
    if not api.isdone('bootstrap'):
        logger.debug("Bootstrapping FreeIPA API ...")
        api.bootstrap(context='cli', log=None)
        api.finalize()

    if not api.Backend.rpcclient.isconnected():
        logger.debug("Connecting to FreeIPA RPC ...")
        api.Backend.rpcclient.connect()

    api.Command.ping()


def create_selfservice_group(name):
    try:
        api.Command.group_add(
            name,
            description=SELFSERVICE_GROUP_DESCRIPTION)
    except errors.DuplicateEntry:
        logger.warn("Group '%s' already exists.", name)
    else:
        logger.info("Created group '%s'", name)


def create_selfservice_permission(name, permtype, memberof=None, extrafilter=None):
    admins = DN(('cn', u'admins'), api.env.container_group, api.env.basedn)
    options = {
        'attrs': [u'passwordhistory', u'userpassword', u'krbprincipalkey'],
        'ipapermbindruletype': u'permission',
        'ipapermright': [u'write'],
        'type': permtype,
        'extratargetfilter': [
            # Explicitly forbid password resets for admins.
            u'(!(memberOf=%s))' % admins,
        ]
    }
    if memberof is not None:
        options['memberof'] = [memberof]
    if extrafilter is not None:
        options['extratargetfilter'].append(extrafilter)
    try:
        api.Command.permission_add(name, **options)
    except errors.DuplicateEntry:
        logger.warn("Permission '%s' already exists.", name)
    else:
        logger.info("Created permission '%s' for '%s'", name, permtype)


def create_automember_rule(groupname, userclass):
    try:
        api.Command.automember_add(
            groupname,
            type=u'group',
            description=SELFSERVICE_AUTOMEMBER_DESCRIPTION)
    except errors.DuplicateEntry:
        logger.warn("Automember rule for group '%s' already exists.",
                    groupname)
    else:
        logger.info("Created automember rule for '%s'", groupname)
    api.Command.automember_add_condition(
        groupname,
        type=u'group',
        key=u'userclass',
        automemberinclusiveregex=userclass,
    )
    logger.info("    Added rule userclass='%s'", userclass)


def create_privilege(name, permissions):
    try:
        api.Command.privilege_add(
            name,
            description=PRIVILEGE_DESCRIPTION)
    except errors.DuplicateEntry:
        logger.warn("Privilege '%s' already exists", name)
    else:
        logger.info("Created privilege '%s'", name)
    for permission in permissions:
        try:
            api.Command.privilege_add_permission(
                name,
                permission=permission)
        except errors.ValidationError:
            logger.warn("    Cannot add permission '%s' to privilege",
                        permission)
        else:
            logger.info("    Added permission '%s' to privilege",
                        permission)


def create_role(name, privilege):
    try:
        api.Command.role_add(
            name,
            description=ROLE_DESCRIPTION)
    except errors.DuplicateEntry:
        logger.warn("Role '%s' already exists", name)
    else:
        logger.info("Created role '%s'", name)

    api.Command.role_add_privilege(name, privilege=privilege)
    logger.info("Added privilege '%s' to role '%s'", privilege, name)


def create_user(name):
    try:
        api.Command.user_add(
            name,
            givenname=USER_FIRST,
            sn=USER_LAST)
    except errors.DuplicateEntry:
        logger.warn("User '%s' already exists", name)
        return False
    else:
        logger.info("Created user '%s'", name)
        return True


def add_role(username, rolename):
    api.Command.role_add_member(rolename, user=username)
    logger.info("Added role '%s' to user '%s'", rolename, username)


def create_keytab(username, keytab, owner):
    if os.path.isfile(keytab):
        logger.warn("Keytab '%s' already exists.", keytab)
        logger.info("Skipping ipa-getkeytab")
        return False

    directory = os.path.dirname(keytab)
    if not os.path.isdir(directory):
        os.makedirs(directory, mode=0o755)

    try:
        server = api.env.server
    except AttributeError:
        # We are running on the same host as the IPA service.
        server = api.env.host

    result = api.Command.user_show(username, all=True)
    result = result[u'result']
    principal = result[u'krbprincipalname'][0]
    cmd = ['ipa-getkeytab', '-s', server, '-p', principal, '-k', keytab]
    # TODO: --retrieve
    logger.info("Retrieving keytab...\n    %s", ' '.join(cmd))
    subprocess.check_call(cmd)
    os.chown(keytab, owner.pw_uid, owner.pw_gid)
    os.chmod(keytab, 0o600)
    return True


def _cleanup(args):
    """Internal testing helper
    """
    commands = [
        ('user_del', args.username, {}),
        ('role_del', args.role, {}),
        ('privilege_del', args.privilege, {}),
        ('automember_del', args.selfservice_group, {'type': u'group'}),
        ('permission_del', SELFSERVICE_USER_PERMISSION, {}),
        ('permission_del', SELFSERVICE_STAGEUSER_PERMISSION, {}),
        ('group_del', args.selfservice_group, {}),
    ]
    for command, arg, kwargs in commands:
        try:
            getattr(api.Command, command)(arg, **kwargs)
        except errors.NotFound:
            logger.info("- %s('%s')", command, arg)
        else:
            logger.info("+ %s('%s')", command, arg)

    try:
        os.unlink(args.keytab)
    except OSError as e:
        logger.error(e)


def main():
    args = parser.parse_args()
    try:
        api_connect()
    except errors.PublicError as e:
        parser.exit(2, "ERROR: FreeIPA is not responding:\n    %s\n" % e)

    # _cleanup(args)

    create_selfservice_group(args.selfservice_group)
    create_selfservice_permission(
        SELFSERVICE_USER_PERMISSION,
        u'user',
        memberof=args.selfservice_group,
    )
    create_selfservice_permission(
        SELFSERVICE_STAGEUSER_PERMISSION,
        u'stageuser',
        extrafilter='(userclass=%s)' % args.automember_userclass,
    )
    create_automember_rule(
        args.selfservice_group,
        args.automember_userclass
    )
    create_privilege(args.privilege, PRIVILEGE_PERMISSIONS)
    create_role(args.role, args.privilege)
    create_user(args.username)
    add_role(args.username, args.role)
    if args.retrieve_keytab:
        create_keytab(args.username, args.keytab, args.keytab_owner)
    parser.exit(0, 'Done')


if __name__ == '__main__':
    handler = logging.StreamHandler()
    formatter = logging.Formatter("%(message)s", None)
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)

    main()
